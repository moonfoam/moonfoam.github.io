---
title: 动态分析测试技术
comments: true
date: 2016-06-20 18:55:20
updated: 2016-06-20 18:55:20
tags: 软件测试基础
categories: 基础知识
---
# 黑盒测试和白盒测试
|项目|黑盒测试|白盒测试|
|:---|:---|:---|
|依据|SRS(软件需求说明书)|LLD(详细设计)|
|目的|从质量特性的不同方面，对软件进行测试，检测该软件是否实现了SRS中所有显示和隐式的需求|利用不同的逻辑率到达某种程度的代码覆盖率|
|步骤|构造输入和预期输出，通过一定的操作步骤来测试软件|**静态分析**和动态分析|
|优点|效率高<br/>不需要了解实现得细节<br/> 测试人员和编程人员是相互独立的<br/>有助于暴露任何与规格不一致或者歧异的地方<br/>用户的角度进行测试，容易被接受和理解|检测代码中的每条路径和分支<br/>揭示隐藏在代码中的错误<br/>对代码的测试进行比较彻底|
|缺点|不能测试程序内部特定部位<br/>如果程序未执行的代码无法发现<br/>没有清晰的和简明的规格，测试用例很难被设计<br/>|投入较大 成本较高<br/>不验证规格的正确性<br/>无法检查代码中遗漏的路径和数据敏感性错误<br/>|
<!--more-->


# 黑盒测试
## 功能测试依据
- 不深入代码细节的软件测试是动态黑盒测试
- 良好的规格说明将提供软件的输入条件和输出结果
- 如果没有规格测试说明，则需进行探索测试，即吧软件当作规格说明来对待，分步骤逐项探索软件特征。记录执行情况，详细描述功能。但无法判定是否有功能遗漏

## 目的
- 是否有不正确或遗漏的功能
- 在接口上，输入输出是否正确
- 是否有数据结构错误或外部信息访问错误
- 性能上是否能够满足要求
- 是否有初始化或终止性错误

## 用例设计方法
- 等价类划分
- 边界值分析
- 因果图和判定表驱动法
- 状态图法
- 用例图法

## 通过测试&失败测试
- 通过测试是确认软件基本功能**是否得以实现**
- 失败测试是纯粹**为了破坏软件**而设计和执行某些测试用例

## 等价类划分
- 完全不考虑程序的**内部结构**，只依据程序的**规格说明**来设计测试用例
- 等价类划分方法把所有**可能的输入数据**，即程序的输入域**划分成若干部分**，然后从每一部分中选取**少数有代表性的数据**做为测试用例
- 使用这一方法设计测试用例要经历划分等价类（列出等价类表）和选取测试用例两步

### 等价类的划分
  - 有效等价类
    - 是指对于程序的规格说明来说，是**合理的**，**有意义的**输入数据构成的集合。
  - 无效等价类
    - 是指对于程序的规格说明来说，是**不合理的**，**无意义的**输入数据构成的集合
  - 在设计测试用例时，要同时考虑有效等价类和无效等价类的设计

### 确定测试用例
- 在确立了等价类之后，建立等价类表，列出所有划分出的等价类
- 再从划分出的等价类中按以下原则选择测试用例
  1. 为每一个等价类规定一个唯一编号
  2. 设计一个新的测试用例，使其**尽可能多地覆盖**尚未被覆盖的**有效等价类**，重复这一步，直到所有的有效等价类都被覆盖为止
  3. 设计一个新的测试用例，使其**仅覆盖一个**尚未被覆盖的**无效等价类**，重复这一步，直到所有的无效等价类都被覆盖为止


> z.B
> 设有一个档案管理系统，要求用户输入以年月表示的日期。假设日期限定在1990年1月~2049年12月，并规定日期**由6位数字字符**组成，**前4位表示年**，**后2位表示月**。现用**等价类划分法**设计测试用例，来测试程序的"日期检查功能"
>
> |输入等价类|有效等价类|无效等价类|
> |:-------|:-------|:-------|
> |日期的类型及长度|<1> 6位数字字符|<2> 有非数字字符<br/><3> 少于6位数字字符<br/><4> 多于6位数字字符|
> |年份范围|<5> 在1990~2049之间|<6> 小于1990<br/><7> 大于2049|
> |月份范围|<8> 在01~12之间|<9> 等于00<br/><10> 大于12|

## 边界值分析
- 边界值分析也是一种黑盒测试方法，是**对等价类划分方法的补充**
- 人们从长期的测试工作经验得知，**大量的错误是发生在输入或输出范围的边界上**，而不是在输入范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误

### 设计测试用例
- 首先应确定边界情况。应当选取**正好等于**，**刚刚大于**，或**刚刚小于**边界的值做为测试数据，而不是选取等价类中的典型值或任意值做为测试数据
> z.B.
> 1. 对16-bit 的整数而言 32767 和 -32768 是边界
> 2. 屏幕上光标在最左上、最右下位置
> 3. 报表的第一行和最后一行
> 4. 数组元素的第一个和最后一个
> 5. 循环的第 0 次、第 1 次和倒数第 2 次、最后一次

#### 基础边界值分析
- “单缺陷”假设：失效**极少**是由两个（或多个）缺陷**同时发生**引起的。因此，边界值分析测试用例的获得，通过使所有变量取正常值，只使一个变量取极值。
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/20d70424a45cf6c24cf2c6c64b7b6526.png?imageView/2/w/500)

#### 健壮性测试
- 边界值分析的一种简单扩展，除了变量的五个边界值分析取值，还要通过采用一个**略超过最大值**的取值，以及一个**略小于最小值**的取值。目的在于观察**例外处理**情况。
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/e585428649752a79c11a4d922dcff0b1.png?imageView/2/w/500)

#### 最坏情况测试
- 对每个变量首先进行包含**min、min+、nom、max－、max五元素**集合的测试，然后对这些集合进行**笛卡儿积**计算，以生成测试用例
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/9d036bcd7c83dfe4b72c8d180716a55c.png?imageView/2/w/500)

#### 健壮最坏情况测试
- 使用健壮性测试的**七元素集合**的**笛卡儿积**生成测试用例
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/a9d9e717e9ef4eabd90d5cb6794af171.png?imageView/2/w/500)

#### 内部边界值分析
- 数值的边界值检验
  - 计算机是基于二进制进行工作的，因此，软件的任何数值运算都有一定的范围限制
- 字符的边界值检验
  - 在计算机软件中，字符也是很重要的表示元素，其中ASCII和Unicode是常见的编码方式

## 因果图
- 如果在测试时必须考虑**输入条件的各种组合**，可使用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来设计测试用例，这就需要利用因果图。**因果图方法最终生成的就是判定表**。它适合于检查程序输入条件的**各种组合情况**

### 基本符号
- 通常在因果图中用Ci表示原因，用Ei表示结果，各结点表示状态，可取值“0”或“1”。“0”表示某状态不出现，“1”表示某状态出现。
#### 原因和结果之间的关系表示
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/46724bebe9726e0d6c497a5ec3e55ce4.png?imageView/2/w/500)
#### 表示约束条件的符号
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/1950c04457385bda7fb823902e520e90.png?imageView/2/w/500)

### 判定表驱动测试
- 判定表可以把**复杂的逻辑关系和多种条件组合**的情况表达得既**明确又具体**

#### 形式
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/b615fa76494624298739758a5fc8a1c2.png?imageView/2/w/500)
- 条件桩：列出问题所有条件
- 动作桩：列出问题规定可能采取的操作
- 条件项：针对条件桩，在所有可能情况下的真假值
- 动作项：列出在条件项的各种取值情况下应该采取的动作

> z.B
> 判定表驱动法实例
> 某航空公司规定，乘客可以免费托运重量不超过30kg的行李。当行李重量超过30kg时，对头等舱的国内乘客超重部分每公斤收费4元，对其他舱的国内乘客超重部分每公斤收费6元，对国外乘客超重部分每公斤收费比国内乘客多一倍，对残疾乘客超重部分每公斤收费比正常乘客少一半
> ![](http://7xqgx7.com1.z0.glb.clouddn.com/38c368ad24ad8201a49af92bd3f779c7.png?imageView/2/w/500)
>
> 因果图和判定表驱动法实例
> 有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：
> 若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。”
>
> **分析,列出原因和结果原因: **
> > 1.售货机有零钱找
> 2.投入1元硬币
> 3.投入5角硬币
> 4.押下橙汁按钮
> 5.押下啤酒按钮
>
> **建立中间结点，表示处理中间状态  **
> >  11.投入1元硬币且押下饮料按钮
> 12.押下〖橙汁〗或〖啤酒〗的按钮
> 13.应当找5角零钱并且售货机有零钱找
> 14.钱已付清
>
> **结果**
> > 21.售货机〖零钱找完〗灯亮
> 22.退还1元硬币
> 23.退还5角硬币
> 24.送出橙汁饮料
> 25.送出啤酒饮料
>
> **画出因果图**
> - 所有原因结点列在左边，所有结果结点列在右边
> - 由于 2 与 3 ，4 与 5 不能同时发生，分别加上约束条件E
> - ![](http://7xqgx7.com1.z0.glb.clouddn.com/68dc5e5beecdb5202350a8d17adb741f.png?imageView/2/w/500)
>
> **转换成判定表**
> - ![](http://7xqgx7.com1.z0.glb.clouddn.com/4328ac97b38aef102c04b6bc0bd82b28.png?imageView/2/w/500)

## 状态图法
- 列出状态和其转换条件
> z.B.
> A simple electronic clock has four modes, display time, change time, display date and change date
> The change mode button switches between display time and display date
> The reset button switches from display time to adjust time or display date to adjust date
> The set button returns from adjust time to display time or adjust date to display date
> -  ![](http://7xqgx7.com1.z0.glb.clouddn.com/3914705b58487bd5f4fb768cb7e4e15f.png?imageView/2/w/400)

- 状态转换树
> z.B.如上题
> - ![](http://7xqgx7.com1.z0.glb.clouddn.com/b0c2fd7b8c02e5b63d52a16bfa80467c.png?imageView/2/w/400)

## 错误推测法
- 人们也可以**靠经验和直觉推测**程序中可能存在的各种错误，从而有针对性地编写检查这些错误的例子。这就是错误推测法。错误推测法的基本想法是：列举出程序中所有可能有的错误和**容易发生错误的特殊情况**，根据它们选择测试用例

# 白盒测试
## 逻辑覆盖
- 逻辑覆盖是以**程序内部的逻辑结构**为基础的设计测试用例的技术
  - 语句覆盖
  - 判定覆盖
  - 条件覆盖
  - 判定-条件覆盖
  - 条件组合覆盖
  - 修正后的判定-条件覆盖

### 例图
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/1735311556ff1fcb2d0cff0d316a7f7b.png?imageView/2/w/500)

### 语句覆盖
- 设计若干个测试用例，运行被测程序，**使得每一可执行语句至少执行一次**
- 如例图中a-c-e路线可达到语句覆盖目的

### 判定覆盖
- 又称为**分支覆盖**
- 设计若干个测试用例，运行被测程序，使得程序中**每个判断的取真分支和取假分支至少经历一次**
- 如例图中(a-c-e & a-b-d)或者(a-c-d & a-b-e) 路线可达到判定覆盖目的

### 条件覆盖
- 设计若干个测试用例，运行被测程序，使得程序中每个判断的**每个条件的可能取值**至少执行一次
- 在图例中，我们事先可对所有条件的取值加以标记。例如
  - 对于第一个判断
    - 条件 A＞1 取真为T1，取假为~T1
    - 条件 B＝0 取真为T2，取假为~T2
  - 对于第二个判断
    - 条件A＝2 取真为T3，取假为~T3
    - 条件X＞1 取真为T4，取假为~T4

> |测试用例|覆盖分支|条件取值|
> |:----|:------|:------|
> |(2,0,4)|L1(c,e)| T1 T2 T3 T4|
> |(1,0,1)|L2(b,d)|~T1 T2~T3 T4|
> |(2,1,1)|L3(b,e)| T1~T2 T3~T4|
>
> or
>
> |测试用例|覆盖分支|条件取值|
> |:----|:------|:------|
> |(1,0,3)|L3(b,e)|~T1 T2~T3 T4|
> |(2,1,1)|L3(b,e)| T1~T2 T3~T4|

### 判定-条件覆盖
- 设计足够的测试用例，使得判断中**每个条件的所有可能取值至少执行一次**，同时每个判断中的**每个条件的可能取值至少执行一次**
- 在图例中:

> |测试用例|覆盖分支|条件取值|
> |:----|:------|:------|
> |(2,0,4)|L1(c,e)|T1 T2 T3 T4|
> |(1,1,1)|L2(b,d)|~T1~T2~T3~T4|

### 条件组合覆盖
- 计足够的测试用例，运行被测程序，使得**每个判断的所有可能的条件取值组合至少执行一次**
- 在图例中,有

|组合|标记|
|:------|:------|
|A＞1 B＝0|T1 T2|
|A＞1 B≠0 |T1~T2|
|A≯1 B＝0|~T1 T2|
|A≯1 B≠0|~T1~T2|
|A＝2 X＞1|T3 T4|
|A＝2 X≯1|T3~T4|
|A≠2 X＞1|~T3 T4|
|A≠2 X≯1|~T3~T4|

> |测试用例|覆盖分支|条件取值|
> |:----|:------|:------|
> |(2,0,4)|L1|T1 T2 T3 T4|
> |(2,1,1)|L3|T1~T2 T3~T4|
> |(1,0,3)|L3|~T1 T2~T3 T4|
> |(1,1,1)|L2|~T1~T2~T3~T4|

### 路径覆盖
- 设计足够的测试用例，**覆盖程序中所有可能的路径**
- 如例图中a-c-e & a-c-d & a-b-e & a-b-d 路线可达到语句覆盖目的

## 路径分析
- 对于比较简单的小程序实现路径覆盖是可以做到的，但如果程序中出现多个判断和多个循环，可能的路径数目将会急剧增长，以至实现路径覆盖不可能做到。实际上我们可以做到的只能是程序中主要路径的测试


#### 程序的复杂度计算
- 有了描绘程序控制流的流图之后，可以用下述三种方法之一来计算复杂度
  - 流图中的**区域数**等于环形复杂度
  - 流图G的环形复杂度V(G)＝E-N+2，其中E是流图中边的条数，N是流图中节点数
  - 流图G的环形复杂度V(G)＝P+1   其中P是流图中判定节点的数目。
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/6aafd855e47f39da90825b86d4b382a9.png?imageView/2/w/500)

#### 基本路径测试
- 基本路径测试方法把覆盖的路径数**压缩到一定限度**内，程序中的**循环体最多只执行一次**
- 它是在程序控制流图的基础上，分析控制构造的环路复杂性，导出基本可执行路径集合，设计测试用例的方法。设计出的测试用例要保证在测试中，程序的**每一个可执行语句至少要执行一次**
> ![](http://7xqgx7.com1.z0.glb.clouddn.com/049737a2a82d274491e718b4e9e599b0.png?imageView/2/w/500)

#### 程序路径表达式
- 路径的弧序列表示及节点序列表示
- 路径表达式：其运算的对象是控制流图中的弧，此外还引入两个运算：加和乘
  - 弧a和弧b相乘，所得到的乘积为ab，它表示先沿弧a，再沿弧b所经历的路线
  - 弧a和弧b相加，其和a＋b表示两弧是或的关系。
- ![](http://7xqgx7.com1.z0.glb.clouddn.com/16770c6cc62ac42f7171289afa4a0ea2.png)
  - e\*(a\+b)\*(c\+d)\*f
- 程序中路径数的计算
  - 如果得到了程序的路径表达式，则可把其中的所有弧均**带以数值“1”**，然后依表达式的乘法和加法运算，**所得到数值即为该程序的路径数**
  - z.B. 如上例所示路径数为1\*2\*2\*1=4

## 域测试
- 域测试是一种基于程序结构的测试方法，现已经发展成为一个模块测试的有效方法。
- 域测试中的“域”指的是程序的输入空间。域测试方法是基于对**输入空间**的分析。

### 错误分类
- 域测试将程序错误分为**域错误**、**计算型错误** 和**丢失路径错误**三种。域测试**主要针对域错误**。
  - 域错误
    - 如果程序的控制流有错误，对于某一特定的输入可能执行的是一条**错误路径**
  - 计算型错误
    - 如果对于特定输入执行的是正确路径，但**由于赋值语句的错误**致使输出结果不正确
  - 丢失路径错误
    - 由于程序中某处**少了一个判定谓词**而引起的

### 局限性
- 域测试使用时有些限制条件，如程序中**不能出现数组、子函数、分支谓词是简单谓词**等，并且还涉及到**多维空间**的概念，不易被人们接受，也就在一定程度上影响了它的实用性和推广

## 符号测试
- 符号测试的基本思想是允许程序输入的不仅仅是具体的**数值数据**，而且**包括符号值**，符号值可以是基本符号变量，也可以是这些符号变量值的一个表达式
- 在执行程序过程中**以符号的计算代替了普通测试执行中对测试用例的数值计算**，所得到的结果自然是符号公式或符号谓词，即普通测试执行的是算术运算，符号测试执行的是代数运算
- 符号测试可以认为是普通测试的一个自然的扩充

### 符号执行树
- 取符号值作为输入数据，在执行过程中，**如果遇到条件语句**，就无法决定执行哪一个分支，这时我们必须**保留两个分支**，分别做进一步的探索。在后面的执行中，凡遇到条件判断，都会出现类似的情况
- 如果程序中**仅有IF构成的分支**，那么符号执行的过程可用一个**二叉树**来描述，我们称之为*执行树*，把在各分支点的谓词条件累积在一起，用**逻辑乘**符号连接起来，得到的这个逻辑表达式称为**路径条件**,路径条件是路径的谓词系统，它是多个等式或不等式的交

### 优缺点
- 优点
  - 符号测试可以很容易地确定所给的一组测试用例是否覆盖了程序的各条路径
- 缺点
  - 分支问题
  - 二义性问题
  - 大程序问题
